# Follow-up to DAL Exercise 1

## First Impressions of "Looking Around"

Probably one of the things that became clear when you started trying to look things up and add your own links to the document is that...*nothing was really that clear!*

> What are all these things? What are they talking about? Why does what I'm reading appear to be *like* English, except without referring to anything that is useful or meaningful to me? 

Or maybe you didn't have this experience (maybe looking around merely seemed pointless in a dull, unexasperating way, like sitting in a bland dentist's office).

Whatever the case, it was important for you to begin to get an impression of:

1. actually how vast the world of programming and programming languages is, which hopefully you got from looking at links in the **Languages and Environments**

2. what some of the tools are that will be important to us from the get-go (we'll be using the terminal or Terminal.app and *homebrew* together in this particular exercise).

3. how learning a programming language is not all that different from learning a new spoken or written language (and often with it a new culture), which is why borrowing memorization techniques for learning foreign languages and such may be relevant.

4. the hard truth that doing interesting stuff with software is made harder or easier by the intentions of the people responsible for it. The first exercise was not meant to be especially fun or exciting because I made it that way--whoops! 

## Thanks a lot, brah
This last point may seem to reflect a miscalculation: shouldn't you want to start people out with the most exciting and fun stuff? For children and people with short attention spans and little patience, yes, that's the way to start. 

But things are different for quasi-adults who maybe have typically been more interested in things with some immediate payoff, say like art-making or writing (or music, where, if you just have an instrument you can technically "make music" with little effort, as anyone who has ever witnessed a baby banging a piano can attest). There's really no point in hiding from these people that delayed gratification is an often unmentioned part of any kind of programming pedagogy (this is one of the reasons for doing things like tracking the time we spend carefully--we need to more closely monitor ourselves and our motivation if we're going to stick with it).

With that out of the way, we can move on to demonstrations of things that *are* more exciting, but hopefully we will now not take for granted that they are fun and exciting *precisely because someone took great pains to make it easier for us*. 

Just how that is different from what you will eventually be doing, and what exactly is involved in the "great pains" that programmers typically take, will gradually become clear if you indeed stick with it. More importantly, what will be become clear (once you work through the ungratifying delays) is the sublime and weird joy of creating something with a computer that **does what you want it to**. 

I can't wait (hahahah. get it?)






